/*
	Copyright Â© Bryan Apellanes 2015  
*/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Bam.Data.Repositories;
using Bam.Data.Schema;
using Bam.Net.Data.Schema;
using Bam.Net.Data.SQLite;
using Bam.Net.Logging;

namespace Bam.Net.Data.Repositories
{
    /// <summary>
    /// A repository that generates an underlying Dao
    /// for the types added.  Any values returned by a 
    /// call to Query are not fully hydrated (child lists
    /// won't be populated) as well as any child lists of child 
    /// list elements.  To ensure full hydration of
    /// the values call Retrieve(id) or Retrieve(uuid).    
    /// </summary>
    [Serializable] // for memory size calculation
    public class DaoRepository : Repository, IDaoRepository, IGeneratesDaoAssembly, IHasTypeSchemaTempPathProvider, IQueryFilterable
    {
        public DaoRepository(ISchemaProvider schemaGenerator, IDaoGenerator daoGenerator, IWrapperGenerator wrapperGenerator)
        {
            this.SchemaGenerator = schemaGenerator;
            this.TypeToDaoGenerator = new TypeToDaoGenerator(SchemaGenerator, daoGenerator, wrapperGenerator);

            this.TypeToDaoGenerator.SchemaWarning += (o, a) => FireEvent(SchemaWarning, a);

            this.TypeToDaoGenerator.GenerateDaoAssemblySucceeded += (o, a) =>
            {
                GenerateDaoAssemblyEventArgs args = (GenerateDaoAssemblyEventArgs)a;
                FireEvent(GenerateDaoAssemblySucceeded, args);
            };

            this.NullifyDaoAssemblyOnAddType = true;
            this.WrapByDefault = true;
            this.WarningsAsErrors = true;

            this.Database = DataProvider.Current.GetSysDatabaseFor(this);
            this.Logger = Log.Default;
        }

        public DaoRepository(ISchemaProvider schemaGenerator, IDaoGenerator daoGenerator, IWrapperGenerator wrapperGenerator, IDatabase? database, ILogger? logger)
            : this(schemaGenerator, daoGenerator, wrapperGenerator)
        {
            this.Database = database ?? DataProvider.Current.GetSysDatabaseFor(this);
            this.Logger = logger ?? Log.Default;
            this.Subscribe(Logger);
        }

        protected TypeToDaoGenerator TypeToDaoGenerator
        {
            get; set;
        }

        protected ISchemaProvider SchemaGenerator
        {
            get; set;
        }

        /// <summary>
        /// The namespace to place generated classes into
        /// </summary>
        public string DaoNamespace
        {
            get
            {
                return TypeToDaoGenerator.DaoNamespace;
            }
            set
            {
                TypeToDaoGenerator.DaoNamespace = value;
            }
        }

        string _baseNamespace;

        /// <summary>
        /// The namespace containing POCO types to generate dao types for.  Setting 
        /// the BaseNamespace also sets the DaoNamespace
        /// and WrapperNamespace.
        /// </summary>
        public string BaseNamespace
        {
            get
            {
                return _baseNamespace;
            }
            set
            {
                _baseNamespace = value;
                TypeToDaoGenerator.BaseNamespace = _baseNamespace;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to
        /// keep the source generated by the TypeDaoGenerator
        /// </summary>
        public bool KeepSource
        {
            get
            {
                return TypeToDaoGenerator.KeepSource;
            }
            set
            {
                TypeToDaoGenerator.KeepSource = value; 
            }
        }

        public Func<IDaoSchemaDefinition, ITypeSchema, string> TypeSchemaTempPathProvider
        {
            get
            {
                return TypeToDaoGenerator.TypeSchemaTempPathProvider;
            }
            set
            {
                TypeToDaoGenerator.TypeSchemaTempPathProvider = value;
            }
        }

        public string SchemaName
        {
            get
            {
                return TypeToDaoGenerator.SchemaName;
            }
            set
            {
                TypeToDaoGenerator.SchemaName = value;
            }
        }

        /// <summary>
        /// If true query results are wrapped
        /// to enable lazy loading of child collections;
        /// the default is true.  Can cause a performance
        /// hit for large result sets.
        /// </summary>
        public bool WrapByDefault
        {
            get;
            set;
        }

		public bool WarningsAsErrors
        {
            get { return TypeToDaoGenerator.WarningsAsErrors; }
            set { TypeToDaoGenerator.WarningsAsErrors = value; }
        }

		public IDatabase Database { get; set; }

		[Verbosity(VerbosityLevel.Information)]
		public event EventHandler GenerateDaoAssemblySucceeded;		

		public IDaoSchemaDefinition SchemaDefinition
		{
			get
			{
				return TypeToDaoGenerator.SchemaDefinitionCreateResult.SchemaDefinition;
			}
		}

        TypeSchema _typeSchema;
		public ITypeSchema TypeSchema
		{
			get
			{
                if(_typeSchema == null)
                {
                    Initialize();
                    _typeSchema = SchemaGenerator.CreateTypeSchema(StorableTypes, SchemaName);
                }
                return _typeSchema;
			}
		}

        [Verbosity(VerbosityLevel.Warning, SenderMessageFormat = "Missing {PropertyType} property: {ClassName}.{PropertyName}")]
        public event EventHandler SchemaWarning;

        Assembly _daoAssembly;
        /// <summary>
        /// The assembly to look for Dao definitions in.
        /// This may or may not be generated and can be
        /// user/developer specified
        /// </summary>
        public Assembly DaoAssembly
        {
            get
            {
                return _daoAssembly;
            }
            set
            {
                _daoAssembly = value;
                NullifyDaoAssemblyOnAddType = false;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether adding a type will set the 
        /// DaoAssembly to null, effectively requiring that it be regenerated.  
        /// Directly setting the DaoAssembly sets this to false.  If the 
        /// DaoAssembly has already been set and you wish for it not to be reset, 
        /// set this to false.  The default value is true;
        /// </summary>
        protected bool NullifyDaoAssemblyOnAddType { get; set; }

        protected EnsureSchemaStatus SchemaStatus { get; set; }
        /// <summary>
        /// Generates a Dao Assembly for the underlying 
        /// storable types if it has not yet been generated
        /// </summary>
        /// <returns></returns>
		public Assembly EnsureDaoAssemblyAndSchema(bool useExisting = true)
        {            
            if (_daoAssembly == null)
            {
                _daoAssembly = GenerateDaoAssembly(useExisting);
            }

            Args.ThrowIfNull(Database, "Database");
            if (SchemaStatus == EnsureSchemaStatus.Invalid) 
            {
                MultiTargetLogger logger = new MultiTargetLogger();
                Subscribers.Each(l => logger.AddLogger(l));
                SchemaStatus = Database.TryEnsureSchema(_daoAssembly.GetTypes().First(type => type.HasCustomAttributeOfType(out TableAttribute attr) && attr.ConnectionName.Equals(SchemaName)), logger);
            }

            return _daoAssembly;
        }

        public sealed override void Subscribe(ILogger logger)
        {
            TypeToDaoGenerator.Subscribe(logger);
            SchemaGenerator.Subscribe(logger);
            base.Subscribe(logger);
        }

        /// <summary>
        /// Sets the DaoNamespace to equal the namespace
        /// of the specified type with the suffix .Dao
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public string SetDaoNamespace<T>()
        {
            return SetDaoNamespace(typeof(T));
        }

        /// <summary>
        /// Sets the DaoNamespace to equal the namespace of the specified
        /// type with the suffix .Dao
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public string SetDaoNamespace(Type type)
        {
            DaoNamespace = $"{type.Namespace}.Dao";
            return DaoNamespace;
        }

        public Assembly GenerateDaoAssembly(bool useExisting = true)
        {
            Initialize();
            _daoAssembly = TypeToDaoGenerator.GetDaoAssembly(useExisting);
            Log.WarnIf(_daoAssembly == null, "Unable to generate dao assembly");
            return _daoAssembly;
        }

        bool isInitialized;
		readonly object _initLock = new object();
		public virtual void Initialize()
		{
            if (!isInitialized)
            {
                lock (_initLock)
                {
                    if (!isInitialized)
                    {
                        if (!StorableTypes.Any())
                        {
                            throw new InvalidOperationException("No types were specified.  Call AddType for each type to store.");
                        }
                        isInitialized = true;
                        TypeToDaoGenerator.AddTypes(StorableTypes);
                    }
                }
            }
		}

        public void AddReferenceAssemblies(params Assembly[] assemblies)
        {
            foreach(Assembly assembly in assemblies)
            {
                TypeToDaoGenerator.AddReferenceAssembly(assembly);
            }
        }

        /// <summary>
        /// Convert the specified instance to it's dynamic
        /// json safe representation
        /// </summary>
        /// <param name="instance"></param>
        /// <returns></returns>
        public object ToDto(object instance)
        {
            Type daoType = GetDaoType(instance.GetType());
            Dao o = (Dao)daoType.Construct();
            o.CopyProperties(instance);
            return o.ToJsonSafe();
        }

        /// <summary>
        /// Add the specified type as a storable type.
        /// When the underlying schema is generated for the 
        /// specified type it will be analyzed for its 
        /// relationships to other types as necessary
        /// and those types will be included in the 
        /// resulting schema
        /// </summary>
        /// <param name="type"></param>
		public override void AddType(Type type)
		{
			if (type.GetProperty("Id") == null &&
				type.GetFirstProperyWithAttributeOfType<KeyAttribute>() == null)
			{
				throw new NoIdPropertyException(type);
			}
            if(!StorableTypes.Any())
            {
                SetDaoNamespace(type);
            }
			base.AddType(type);
            if (NullifyDaoAssemblyOnAddType)
            {
                _daoAssembly = null;
            }
		}

		/// <summary>
		/// Creates (Saves) the specified instance of T.  While
		/// the parameter value specified will be updated with 
		/// the newly assigned Id, one should favor using the
		/// return value instead as it will be an augmented extension
		/// of T.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="toCreate"></param>
		/// <returns></returns>
		public override T Create<T>(T toCreate)
		{
			return (T)Create((object)toCreate);
		}
        public override object Create(object toCreate)
        {
            return Create(toCreate.GetType(), toCreate);
        }

        public override object Create(Type type, object toCreate)
		{
			try
			{
				Initialize();
				Type daoType = GetDaoType(GetBaseType(type));
				Dao daoInstance = daoType.Construct<Dao>();
				daoInstance.ForceInsert = true;
				object poco = SaveDaoInstanceProperties(toCreate, daoInstance);
				return poco;
			}
			catch (Exception ex)
			{
				LastException = ex;
				OnCreateFailed(new RepositoryEventArgs(ex));
				return null;
			}
		}

		public override T Retrieve<T>(int id)
		{
			return Retrieve<T>((ulong)id);
		}

		public override T Retrieve<T>(long id)
		{
			return (T)Retrieve(typeof(T), id);
		}
        
        public override T Retrieve<T>(ulong id)
        {
            return (T)Retrieve(typeof(T), id);
        }

        public override object? Retrieve(Type objectType, long id)
        {
            try
            {
                Initialize();
                Dao daoInstance = GetDaoInstanceById(objectType, id);
                if (daoInstance != null)
                {
                    return CreateWrapperCopy(objectType, daoInstance);
                }
                return null;
            }
            catch (Exception ex)
            {
                LastException = ex;
                OnRetrieveFailed(new RepositoryEventArgs(ex));
                return null;
            }
        }

        public override object? Retrieve(Type objectType, ulong id)
		{
			try
			{
				Initialize();
				Dao daoInstance = GetDaoInstanceById(objectType, id);
				if (daoInstance != null)
				{
					return CreateWrapperCopy(objectType, daoInstance);
				}
				return null;
			}
			catch (Exception ex)
			{
				LastException = ex;
				OnRetrieveFailed(new RepositoryEventArgs(ex));
				return null;
			}
		}

        /// <summary>
        /// Retrieve the object with the specified uuid.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <param name="uuid"></param>
        /// <returns></returns>
        public override T Retrieve<T>(string uuid)
        {
            return (T)Retrieve(typeof(T), uuid);
        }

        /// <summary>
        /// Retrieve the object with the specified uuid.
        /// </summary>
        /// <param name="objectType">The type.</param>
        /// <param name="uuid">The universally unique identifier.</param>
        /// <returns>The result.</returns>
		public override object? Retrieve(Type objectType, string uuid)
		{
			try
			{
				Initialize();
				Dao daoInstance = GetDaoInstanceByUniversalIdentifier(objectType, uuid);
				if (daoInstance != null)
				{
					return CreateWrapperCopy(objectType, daoInstance);
				}
				return null;
			}
			catch (Exception ex)
			{
				LastException = ex;
				OnRetrieveFailed(new RepositoryEventArgs(ex));
				return null;
			}
		}

        /// <summary>
        /// Retrieve all entries for the specified generic type.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>A collection of results.</returns>
		public override IEnumerable<T> RetrieveAll<T>()
		{
            WarnRetrieveAll(typeof(T));
			return RetrieveAll(typeof(T)).CopyAs<T>();
		}

        /// <summary>
        /// Retrieve all entries for the specified type.
        /// </summary>
        /// <param name="dtoOrPocoType">The type.</param>
        /// <returns>A collection of results.</returns>
		public override IEnumerable<object> RetrieveAll(Type dtoOrPocoType)
		{
            Args.ThrowIfNull(Database, "Database");

            Type pocoType = GetBaseType(dtoOrPocoType);
            Type daoType = GetDaoType(pocoType);
            MethodInfo getterMethod = daoType.GetMethod("LoadAll", new Type[] { typeof(Database) });
            return new List<object>((IEnumerable<object>)getterMethod.Invoke(null, new object[] { Database }));
        }

        /// <summary>
        /// Retrieve all entries of the specified type in the specified batch size.
        /// </summary>
        /// <param name="dtoOrPocoType">The type.</param>
        /// <param name="batchSize">The batch size.</param>
        /// <param name="processor">The action to perform on each batch.</param>
        public override void BatchRetrieveAll(Type dtoOrPocoType, int batchSize, Action<IEnumerable<object>> processor)
        {
            Args.ThrowIfNull(Database, "Database");

            Type pocoType = GetBaseType(dtoOrPocoType);
            Type daoType = GetDaoType(pocoType);
            MethodInfo getterMethod = daoType.GetMethod("BatchAll", new Type[] { typeof(Database) });
            getterMethod.Invoke(null, new object[] { batchSize, processor, Database });
        }

        /// <summary>
        /// Execute a non typed query.
        /// </summary>
        /// <param name="propertyName">The property.</param>
        /// <param name="value">The value.</param>
        /// <returns>A collection of results.</returns>
		public override IEnumerable<object> Query(string propertyName, object value)
		{
			return Query(DefaultType, Bam.Net.Data.Query.Where(propertyName) == value).CopyAs(DefaultType);
		}

        /// <summary>
        /// Execute a query.
        /// </summary>
        /// <remarks>
        /// Note: hat this method retrieves all the instances of the specified type and then filters them using the specified filterPredicate function.  This will have a detrimental affect on performance if many entries exist for the specified type.
        /// </remarks>
        /// <typeparam name="T">The type.</typeparam>
        /// <param name="filterPredicate">The filter predicate.</param>
        /// <returns>A collection of results.</returns>
        public override IEnumerable<T> Query<T>(Func<T, bool> filterPredicate)
		{
            WarnRetrieveAll<T>();
            return RetrieveAll(typeof(T)).CopyAs<T>().Where(filterPredicate);
		}

        /// <summary>
        /// Execute a query.
        /// </summary>
        /// <remarks>
        /// Note: hat this method retrieves all the instances of the specified type and then filters them using the specified filterPredicate function.  This will have a detrimental affect on performance if many entries exist for the specified type.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <param name="filterPredicate">The filter predicate.</param>
        /// <returns>A collection of results.</returns>
		public override IEnumerable<object> Query(Type type, Func<object, bool> filterPredicate)
		{
            WarnRetrieveAll(type);
            return RetrieveAll(type).CopyAs(type).Where(filterPredicate);
		}

        /// <summary>
        /// Execute a query using the specified dynamic object as equality filters.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="queryArguments"></param>
        /// <returns>A collection of results.</returns>
		public override IEnumerable<T> Query<T>(dynamic queryArguments) 
		{
            if(queryArguments is QueryFilter casted)
            {
                return Query<T>(casted);
            }
            return Query<T>((QueryFilter)QueryFilter.FromDynamic(queryArguments));
		}

        /// <summary>
        /// Execute a query using the specified arguments as equality filters.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <param name="queryArguments">The query arguments.</param>
        /// <returns>A collection of results.</returns>
        public override IEnumerable<T> Query<T>(Dictionary<string, object> queryArguments)
        {
            QueryFilter filter = CreateQueryFilter(queryArguments);
            return Query<T>(filter);
        }

        /// <summary>
        /// Execute a query using the specified arguments as equality filters.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="queryArguments">The query arguments.</param>
        /// <returns>A collection of results.</returns>
        public override IEnumerable<object> Query(Type type, Dictionary<string, object> queryArguments)
        {
            QueryFilter filter = CreateQueryFilter(queryArguments);
            return Query(type, filter);
        }

        /// <summary>
        /// Update the specified object instance.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <param name="toUpdate">The object instance to update.</param>
        /// <returns>The updated object instance.</returns>
        public override T Update<T>(T toUpdate)
		{
			return (T)Update((object)toUpdate);
		}

        /// <summary>
        /// Update the specified object instance.
        /// </summary>
        /// <param name="toUpdate">The object instance to update.</param>
        /// <returns>A wrapped copy of the specified objec instance, or null in the case of an exception.  See `LastException` to determine what exception occurred.</returns>
        public override object Update(object toUpdate)
        {
            return Update(toUpdate.GetType(), toUpdate);
        }

        /// <summary>
        /// Update the specified object instance.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="toUpdate">The object instance to update.</param>
        /// <returns>A wrapped copy of the specified objec instance, or null in the case of an exception.  See `LastException` to determine what exception occurred.</returns>
        public override object Update(Type type, object toUpdate)
		{
			try
			{
				Initialize();
				Dao daoInstance = GetDaoInstanceById(type, GetIdValue(toUpdate).Value); 
				return SaveDaoInstanceProperties(toUpdate, daoInstance);
			}
			catch (Exception ex)
			{
				LastException = ex;
				OnUpdateFailed(new RepositoryEventArgs(ex));
				return null;
			}
		}

        /// <summary>
        /// Delete the specified object instance.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <param name="toDelete">The object instance to delete.</param>
        /// <returns>A value that indicates whether the operation succeeded.</returns>
		public override bool Delete<T>(T toDelete)
		{
			return Delete((object)toDelete);
		}

        /// <summary>
        /// Delete the specified object instance.
        /// </summary>
        /// <param name="toDelete">The object instance to delete.</param>
        /// <returns>A value that indicates whether the operation succeeded.</returns>
        public override bool Delete(object toDelete)
        {
            return Delete(toDelete.GetType(), toDelete);
        }

        /// <summary>
        /// Delete the specified instance.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="toDelete">The object instance to delete.</param>
        /// <returns>A value that indicates whether the operation succeeded.</returns>
        public override bool Delete(Type type, object toDelete)
		{
			try
			{
				Initialize();
                ulong id = GetIdValue(toDelete).Value;
                object daoInstance = GetDaoInstanceById(type, id);
				if (daoInstance != null)
				{
					MethodInfo deleteMethod = daoInstance.GetType().GetMethod("Delete", new Type[] { typeof(Database) });
					deleteMethod.Invoke(daoInstance, new object[] { Database });
					return true;
				}
                throw new InstanceNotFoundException(type, id);
			}
			catch (Exception ex)
			{
				LastException = ex;
				OnDeleteFailed(EventArgs.Empty);
				return false;
			}
		}

        /// <summary>
        /// Execute the specified expression as a query.
        /// </summary>
        /// <typeparam name="T">The type to query.</typeparam>
        /// <param name="expression">The expression.</param>
        /// <returns></returns>
        public IEnumerable<T> Query<T>(Expression<Func<T, bool>> expression) where T : class, new()
        {
            DaoExpressionFilter expressionFilter = new DaoExpressionFilter(Logger);
            return Query<T>(expressionFilter.Where<T>(expression));
        }

		#region IDaoRepository Members
        
        /// <summary>
        /// Execute the specified query.
        /// </summary>
        /// <typeparam name="T">The type to query.</typeparam>
        /// <param name="query">The query.</param>
        /// <returns></returns>
		public override IEnumerable<T> Query<T>(IQueryFilter query)
		{
			Type pocoType = typeof(T);
            IEnumerable daoResults = Query(pocoType, query);
            return daoResults.CopyAs<T>();
        }

        /// <summary>
        /// Execute the specified query.
        /// </summary>
        /// <param name="pocoType">The type to query.</param>
        /// <param name="query">The query.</param>
        /// <returns></returns>
        public override IEnumerable<object> Query(Type pocoType, IQueryFilter query)
        {
            return Query(pocoType, query, WrapByDefault);
        }

        /// <summary>
        /// Execute the specified query.
        /// </summary>
        /// <param name="pocoType">The type to query.</param>
        /// <param name="query">The query.</param>
        /// <param name="wrap">A value that indicates whether to wrap the results.</param>
        /// <returns></returns>
        public IEnumerable<object> Query(Type pocoType, IQueryFilter query, bool wrap)
        {
            Type daoType = GetDaoType(pocoType);
            if(daoType == null)
            {
                return new List<object>();
            }
            MethodInfo whereMethod = daoType.GetMethod("Where", new Type[] { typeof(QueryFilter), typeof(Database) });
            IEnumerable daoResults = (IEnumerable)whereMethod.Invoke(null, new object[] { query, Database });
            if (wrap)
            {
                object[] results = Wrap(pocoType, daoResults).ToArray();
                return results;
            }
            else
            {
                object[] results = daoResults.CopyAs(pocoType).ToArray();
                return results;
            }
        }
        #endregion

        /// <summary>
        /// Get the first result for the specified query.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="query"></param>
        /// <returns></returns>
        public T First<T>(IQueryFilter query) where T: new()
        {
            return Top<T>(1, query).FirstOrDefault();
        }

        /// <summary>
        /// Retrieve the top results for the specified query.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="count"></param>
        /// <param name="query"></param>
        /// <returns></returns>
        public IEnumerable<T> Top<T>(int count, IQueryFilter query) where T : new()
        {
            return Top(count, typeof(T), query).CopyAs<T>();
        }

        /// <summary>
        /// Retrieve the top results for the specified query.
        /// </summary>
        /// <param name="count">The number of results to return.</param>
        /// <param name="query">The query.</param>
        /// <param name="sortByColumn">The column to sort by.</param>
        /// <param name="sortOrder">The order to sort by.</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable<T> Top<T>(int count, IQueryFilter query, string sortByColumn, SortOrder sortOrder) where T : new()
        {
            return Top(count, typeof(T), query, sortByColumn, sortOrder).CopyAs<T>();
        }

        /// <summary>
        /// Retrieve the top results for the specified query.
        /// </summary>
        /// <param name="count">The number of results to return.</param>
        /// <param name="pocoType">The type of the poco.</param>
        /// <param name="query">The query.</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable Top(int count, Type pocoType, IQueryFilter query)
        {
            return Top(count, pocoType, query, null, SortOrder.Ascending, WrapByDefault);
        }

        /// <summary>
        /// Retrieve the top results for the specified query.
        /// </summary>
        /// <param name="count">The number of results to return.</param>
        /// <param name="pocoType">The type of the poco.</param>
        /// <param name="query">The query.</param>
        /// <param name="sortByColumn">The column to sort by.</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable Top(int count, Type pocoType, IQueryFilter query, string sortByColumn)
        {
            return Top(count, pocoType, query, sortByColumn, SortOrder.Ascending, WrapByDefault);
        }

        /// <summary>
        /// Retrieve the top results for the specified query.
        /// </summary>
        /// <param name="count">The number of results to return.</param>
        /// <param name="pocoType">The type of the poco.</param>
        /// <param name="query">The query.</param>
        /// <param name="sortByColumn">The column to sort by.</param>
        /// <param name="sortOrder">The order to sort by.</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable Top(int count, Type pocoType, IQueryFilter query, string sortByColumn, SortOrder sortOrder)
        {
            return Top(count, pocoType, query, sortByColumn, sortOrder, WrapByDefault);
        }

        /// <summary>
        /// Retrieve the top results for the specified query.
        /// </summary>
        /// <param name="count">The number of results to return.</param>
        /// <param name="pocoType">The type of the poco.</param>
        /// <param name="query">The query.</param>
        /// <param name="sortByColumn">The column to sort by.</param>
        /// <param name="sortOrder">The order to sort by.</param>
        /// <param name="wrap">A value that indicates whether to wrap the return values.</param>
        /// <returns>IEnumerable</returns>
        public IEnumerable Top(int count, Type pocoType, IQueryFilter query, string sortByColumn, SortOrder sortOrder, bool wrap)
        {
            Type daoType = GetDaoType(pocoType);
            MethodInfo topMethod = daoType.GetMethod("Top", new Type[] { typeof(int), typeof(QueryFilter), typeof(string), typeof(SortOrder), typeof(Database) });
            IEnumerable daoResults = (IEnumerable)topMethod.Invoke(null, new object[] { count, query, sortByColumn, sortOrder, Database });
            if (wrap)
            {
                object[] results = Wrap(pocoType, daoResults).ToArray();
                return results;
            }
            else
            {
                object[] results = daoResults.CopyAs(pocoType).ToArray();
                return results;
            }
        }

        Dictionary<Type, Type> _daoTypeLookup = new Dictionary<Type, Type>();
        object _daoTypeResolverLock = new object();

        /// <summary>
        /// Gets the dao type for the specified poco type.
        /// </summary>
        /// <param name="pocoType"></param>
        /// <returns></returns>
		public Type GetDaoType(Type pocoType)
		{
            if (_daoTypeLookup.ContainsKey(pocoType))
            {
                return _daoTypeLookup[pocoType];
            }
            else
            {
                lock (_daoTypeResolverLock)
                {
                    Assembly daoAssembly = EnsureDaoAssemblyAndSchema();
                    Type baseType = GetBaseType(pocoType);
                    Type daoType = daoAssembly.GetType("{0}.{1}".Format(TypeToDaoGenerator.DaoNamespace, baseType.Name));
                    if (daoType == null)
                    {
                        Type[] daoTypes = daoAssembly.GetTypes().Where(t => t.Name.Equals(baseType.Name) && t.IsSubclassOf(typeof(Dao))).ToArray();
                        Type first = daoTypes.FirstOrDefault();
                        if(daoTypes.Length > 1)
                        {
                            Logger.Warning("Multiple dao types found for poco type ({0}), using ({1}): {3}", pocoType.FullName, first.FullName, string.Join(",", daoTypes.Select(t => t.FullName).ToArray()));
                        }
                        daoType = first;
                    }

                    if (daoType == null)
                    {
                        Logger.Warning("Unable to get dao type for pocoType ({0}): \r\n\tDao Assembly={1}, \r\n\tBase Type={2}, \r\n\tDaoNamespace={3}", pocoType.GetType().Name, daoAssembly.GetFilePath(), baseType.Name, TypeToDaoGenerator.DaoNamespace);
                    }
                    else
                    {
                        _daoTypeLookup.Set(pocoType, daoType);
                    }

                    return daoType;
                }
            }
		}
        
        /// <summary>
        /// Get the wrapper type for the specified developer defined 
        /// dto of type T
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
		public Type GetWrapperType<T>() where T : new()
		{
			return GetWrapperType(typeof(T));
		}

		/// <summary>
		/// Get the wrapper type for the specified poco type.
		/// Will not return null unless the specified pocoType
		/// is null.
		/// </summary>
		/// <param name="baseOrWrapperType"></param>
		/// <returns></returns>
		public Type GetWrapperType(Type baseOrWrapperType)
		{
			if (baseOrWrapperType == null || baseOrWrapperType.Name.EndsWith("Wrapper"))
			{
				return baseOrWrapperType;
			}

			Type daoType = GetDaoType(baseOrWrapperType);
			Type dto = daoType.Assembly.GetType("{0}.{1}Wrapper".Format(TypeToDaoGenerator.WrapperNamespace, baseOrWrapperType.Name));
			Type result = dto ?? baseOrWrapperType;
			return result;
		}

        /// <summary>
        /// Gets the base poco type by analyzing the naming convention
        /// of the specified wrapperType.
        /// </summary>
        /// <param name="wrapperType"></param>
        /// <returns></returns>
		public Type GetBaseType(Type wrapperType)
		{
			string baseTypeName = wrapperType.Name.EndsWith("Wrapper") ? wrapperType.Name.Truncate("Wrapper".Length) : wrapperType.Name;
			Type baseType = TypeSchema.Tables.FirstOrDefault(t => t.Name.Equals(baseTypeName));
			Type result = baseType ?? wrapperType;
			return result;
		}

        /// <summary>
        /// Create a wrapper copy of the specified dao collection.
        /// </summary>
        /// <param name="baseType"></param>
        /// <param name="daoCollection"></param>
        /// <returns></returns>
        public IEnumerable<object> Wrap(Type baseType, IEnumerable daoCollection)
        {
            foreach (object value in daoCollection)
            {
                yield return CreateWrapperCopy(baseType, (Dao)value);
            }
        }

        /// <summary>
        /// Create a wrapper copy of the specified dao collection.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="daoCollection"></param>
        /// <returns></returns>
        public IEnumerable<T> Wrap<T>(IEnumerable daoCollection) where T : new()
        {
            foreach (object value in daoCollection)
            {
                yield return (T)CreateWrapperCopy(typeof(T), (Dao)value);
            }
        }

        /// <summary>
        /// Copy the specified base instance as a wrapper instance to enable lazy loading 
        /// of List and array properties.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="baseInstance"></param>
        /// <returns></returns>
        public T Wrap<T>(T baseInstance)
        {
            return (T)Wrap(typeof(T), baseInstance);
        }

        /// <summary>
        /// Copy the specified base instance as a wrapper instance to enable lazy loading 
        /// of List and array properties.
        /// </summary>
        /// <param name="baseType"></param>
        /// <param name="instance"></param>
        /// <returns></returns>
        public object Wrap(Type baseType, object instance)
        {
            object result = ConstructWrapper(baseType);
            result.CopyProperties(instance);
            SetParentProperties(result);

            return result;
        }

        /// <summary>
        /// Create an instance of the wrapper type of the specified base type.
        /// </summary>
        /// <param name="baseType"></param>
        /// <returns></returns>
		public object ConstructWrapper(Type baseType)
		{
            Type wrapperType = GetWrapperType(baseType);
			ConstructorInfo ctor = wrapperType.GetConstructor(new Type[] { typeof(DaoRepository) });
            object result;
			if (ctor == null)
			{
				ctor = wrapperType.GetConstructor(Type.EmptyTypes);
				if (ctor == null)
				{
					Args.Throw<InvalidOperationException>(
						"The specified type {0} doesn't have a parameterless constructor and no constructor taking a single parameter of type {1}",
						baseType.FullName, typeof(DaoRepository).FullName);
				}

				result = ctor.Invoke(new object[] { });
			}
			else
			{
				result = ctor.Invoke(new object[] { this });
			}

			return result;
		}

        /// <summary>
        /// Gets the dao equivalent of the specified poco.
        /// </summary>
        /// <param name="poco"></param>
        /// <returns></returns>
		public IDao GetDaoInstance(object poco) // required by generated code
		{
			ulong id = GetIdValue(poco).Value;
			Dao dao = GetDaoInstanceById(poco.GetType(), id);
			return dao;
		}

        /// <summary>
        /// Set the collection values on the specified dao by copying them from the appropriate property of the specified poco.
        /// </summary>
        /// <param name="poco"></param>
        /// <param name="daoInstance"></param>
        /// <returns></returns>
		public bool SetDaoCollectionValues(object poco, IDao daoInstance)
		{
			List<ITypeFk> fkDescriptors = TypeSchema.ForeignKeys.Where(tfk => tfk.PrimaryKeyType == GetBaseType(poco.GetType())).ToList();
			bool result = false;
			foreach (TypeFk fkDescriptor in fkDescriptors)
			{
				PropertyInfo childCollectionDaoProperty = GetChildCollectionDaoPropertyForTypeFk(fkDescriptor);
				IEnumerable values = (IEnumerable)fkDescriptor.CollectionProperty.GetValue(poco) ?? new object[] { };
				IAddable daoCollection = (IAddable)childCollectionDaoProperty.GetValue(daoInstance);
				foreach (object o in values)
				{
                    // TODO: define IMetaProvider and inject; extract this code
					Meta.SetUuid(o);
                    Meta.SetCuid(o);
                    // **

					Dao dao = GetDaoType(GetBaseType(o.GetType())).Construct<Dao>();
					dao.CopyProperties(o);
					daoCollection.Add(dao);
					result = true;
				}
			}

			return result;
		}

        /// <summary>
        /// Set the collection values on the specified poco by copying them from the appropriate property of the specified dao.
        /// </summary>
        /// <param name="poco"></param>
        /// <param name="daoInstance"></param>
        /// <returns></returns>
        public bool SetPocoChildCollectionValues(object poco, IDao daoInstance)
        {
            List<ITypeFk> fkDescriptors = TypeSchema.ForeignKeys.Where(tfk => tfk.PrimaryKeyType == GetBaseType(poco.GetType())).ToList();
            bool result = false;
            foreach (TypeFk fkDescriptor in fkDescriptors)
            {
                Type arrayOrListType = fkDescriptor.CollectionProperty.PropertyType;
                PropertyInfo childCollectionDaoProperty = GetChildCollectionDaoPropertyForTypeFk(fkDescriptor);                
                IEnumerable daoCollection = (IEnumerable)childCollectionDaoProperty.GetValue(daoInstance);
                if(!arrayOrListType.IsArray && arrayOrListType.IsEnumerable())
                {
                    SetPocoListFromDaoCollection(fkDescriptor, poco, daoCollection);
                }
                else
                {
                    SetPocoArrayFromDaoCollection(fkDescriptor, poco, daoCollection);
                }

            }
            return result;
        }

        
        /// <summary>
        /// Sets the cross reference properties from the specified poco wrapper to the specified dao instance.
        /// </summary>
        /// <param name="pocoWrapper"></param>
        /// <param name="daoInstance"></param>
        /// <returns></returns>
		public bool SetDaoXrefCollectionValues(object pocoWrapper, IDao daoInstance)
		{
			Type baseType = GetBaseType(pocoWrapper.GetType());
			Type daoType = GetDaoType(baseType);
            IHasUpdatedXrefCollectionProperties? xrefPropertyProvider = pocoWrapper as IHasUpdatedXrefCollectionProperties;
			bool result = false;
			HashSet<string> handledProperties = new HashSet<string>();
			if (xrefPropertyProvider != null)
			{
				handledProperties = new HashSet<string>(xrefPropertyProvider.UpdatedXrefCollectionProperties.Keys.ToList());
				xrefPropertyProvider.UpdatedXrefCollectionProperties.Keys.BackwardsEach(daoXrefPropertyName =>
				{
					PropertyInfo? daoXrefProperty = daoType.GetProperty(daoXrefPropertyName);
                    if(daoXrefProperty != null)
                    {
                        PropertyInfo pocoProperty = xrefPropertyProvider.UpdatedXrefCollectionProperties[daoXrefPropertyName];
                        bool valuesWereSet = SetDaoXrefCollectionValues(pocoWrapper, daoInstance, daoXrefProperty, pocoProperty);
                        if (result == false && valuesWereSet)
                        {
                            result = true;
                        }
                    }
				});
			}

			ITypeXref[] leftXrefs = TypeSchema.Xrefs.Where(xref => xref.Left.Equals(baseType)).ToArray();
			foreach (TypeXref leftXref in leftXrefs)
			{
				string daoXrefPropertyName = "{0}".Format(leftXref.Right.Name).Pluralize();
				if (!handledProperties.Contains(daoXrefPropertyName))
				{
					PropertyInfo? daoXrefProperty = daoType.GetProperty(daoXrefPropertyName);
					PropertyInfo pocoXrefProperty = leftXref.RightCollectionProperty;
					bool valuesWereSet = SetDaoXrefCollectionValues(pocoWrapper, daoInstance, daoXrefProperty, pocoXrefProperty);
					if(result == false && valuesWereSet)
                    {
                        result = true;
                    }
				}
			}

			ITypeXref[] rightXrefs = TypeSchema.Xrefs.Where(xref => xref.Right.Equals(baseType)).ToArray();
			foreach (TypeXref rightXref in rightXrefs)
			{
				string daoXrefPropertyName = "{0}".Format(rightXref.Left.Name).Pluralize();
				if (!handledProperties.Contains(daoXrefPropertyName))
				{
					PropertyInfo daoXrefProperty = daoType.GetProperty(daoXrefPropertyName);
					PropertyInfo pocoProperty = rightXref.LeftCollectionProperty;
					bool valuesWereSet = SetDaoXrefCollectionValues(pocoWrapper, daoInstance, daoXrefProperty, pocoProperty);
					if(result == false && valuesWereSet)
                    {
                        result = true;
                    }
				}
			}
			return result;
		}

        /// <summary>
        /// Sets the enumerable properties on the specified poco from the specified daoInstance.
        /// </summary>
        /// <param name="pocoWrapper"></param>
        /// <param name="daoInstance"></param>
        public void SetPocoXrefCollectionValues(object pocoWrapper, IDao daoInstance)
        {
            Type baseType = GetBaseType(pocoWrapper.GetType());
            Type daoType = GetDaoType(baseType);
            IHasUpdatedXrefCollectionProperties? xrefPropertyProvider = pocoWrapper as IHasUpdatedXrefCollectionProperties;
            HashSet<string> handledProperties = new HashSet<string>();
            if(xrefPropertyProvider != null)
            {
                handledProperties = new HashSet<string>(xrefPropertyProvider.UpdatedXrefCollectionProperties.Keys.ToList());
                xrefPropertyProvider.UpdatedXrefCollectionProperties.Keys.BackwardsEach(daoXrefPropertyName =>
                {
                    PropertyInfo? daoXrefProperty = daoType.GetProperty(daoXrefPropertyName);
                    if(daoXrefProperty != null)
                    {
                        PropertyInfo pocoXrefProperty = xrefPropertyProvider.UpdatedXrefCollectionProperties[daoXrefPropertyName];
                        SetPocoXrefValues(pocoWrapper, daoInstance, daoXrefProperty, pocoXrefProperty);
                    }
                });
            }

            ITypeXref[] leftXrefs = TypeSchema.Xrefs.Where(xref => xref.Left.Equals(baseType)).ToArray();

            foreach(TypeXref leftXref in leftXrefs)
            {
                string daoXrefPropertyName = leftXref.Right.Name.Pluralize();
                if (!handledProperties.Contains(daoXrefPropertyName))
                {
                    PropertyInfo daoXrefProperty = daoType.GetProperty(daoXrefPropertyName);
                    PropertyInfo pocoXrefProperty = leftXref.RightCollectionProperty;
                    if(daoXrefProperty != null && pocoXrefProperty != null)
                    {
                        SetPocoXrefValues(pocoWrapper, daoInstance, daoXrefProperty, pocoXrefProperty);
                    }
                }
            }

            ITypeXref[] rightXrefs = TypeSchema.Xrefs.Where(xref => xref.Right.Equals(baseType)).ToArray();

            foreach(TypeXref rightXref in rightXrefs)
            {
                string daoXrefPropertyName = rightXref.Left.Name.Pluralize();
                if (!handledProperties.Contains(daoXrefPropertyName))
                {
                    PropertyInfo daoXrefProperty = daoType.GetProperty(daoXrefPropertyName);
                    PropertyInfo pocoXrefProperty = rightXref.LeftCollectionProperty;
                    if(daoXrefProperty != null && pocoXrefProperty != null)
                    {
                        SetPocoXrefValues(pocoWrapper, daoInstance, daoXrefProperty, pocoXrefProperty);
                    }
                }
            }
        }

        public IEnumerable<TChildType> ForeignKeyCollectionLoader<TParentType, TChildType>(object poco) where TChildType : new() // this is used by generated code; JIT compiler can't tell
		{
			ITypeFk? fkDescriptor = TypeSchema.ForeignKeys.FirstOrDefault(tfk => tfk.PrimaryKeyType == typeof(TParentType) && tfk.ForeignKeyType == typeof(TChildType));

			if (fkDescriptor != null)
            {
                return LoadForeignKeyCollection<TChildType>(poco, fkDescriptor);
            }
            return new List<TChildType>();
		}

        /// <summary>
        /// Sets the properties that represent PrimaryKeys.
        /// </summary>
        /// <param name="pocoInstance"></param>
        public void SetParentProperties(object pocoInstance)
		{
			Type pocoType = GetBaseType(pocoInstance.GetType());
			foreach (TypeFk typeFk in TypeSchema.ForeignKeys.Where(fk => fk.ForeignKeyType == pocoType))
			{
				PropertyInfo parentInstanceProperty = pocoType.GetProperty(typeFk.PrimaryKeyType.Name);
				if (parentInstanceProperty != null && !parentInstanceProperty.GetGetMethod().IsVirtual)
				{
					object value = GetParentPropertyOfChild(pocoInstance, typeFk.PrimaryKeyType);
					parentInstanceProperty.SetValue(pocoInstance, value);
				}
			}
		}

		/// <summary>
		/// Get the instance of the parentType specified for the 
		/// specified dto instance
		/// </summary>
		/// <param name="pocoChild"></param>
		/// <param name="parentType"></param>
		/// <returns></returns>
		public object? GetParentPropertyOfChild(object pocoChild, Type parentType)
		{
			Type dtoType = GetWrapperType(pocoChild.GetType());
			if (dtoType != null)
			{
				string primaryIdPropertyName = "{0}Id".Format(parentType.Name);
				PropertyInfo primaryIdProperty = dtoType.GetProperty(primaryIdPropertyName);
				if (primaryIdProperty != null)
				{
					ulong idValue = (ulong)primaryIdProperty.GetValue(pocoChild);
					object parentDaoInstance = GetDaoInstanceById(parentType, idValue);
					if (parentDaoInstance != null)
					{
						object value = parentType.Construct();
						value.CopyProperties(parentDaoInstance);
						return value;
					}
				}
			}

			return null;
		}

        public T Construct<T>() where T : IAuditRepoData, new()
        {
            T result = new T();
            result.Created = DateTime.UtcNow;
            result.Modified = result.Created;
            return result;
        }

		/// <summary>
		/// Get the PropertyInfo that represents the parent object for the specified
		/// TypeFk
		/// </summary>
		/// <param name="typeFk"></param>
		/// <returns></returns>
		protected internal PropertyInfo GetParentDaoPropertyOfChildForTypeFk(TypeFk typeFk)
		{
			// ParentType.Name Of ForeignKeyProperty.Name
			Type foreignKeyDaoType = GetDaoType(typeFk.ForeignKeyType);
			string propertyName = string.Format("{0}Of{1}", foreignKeyDaoType.Name, typeFk.ForeignKeyProperty.Name);
			PropertyInfo parentPropertyOfChildForTypeFk = foreignKeyDaoType.GetProperty(propertyName);
			return parentPropertyOfChildForTypeFk;
		}

		/// <summary>
		/// Get the PropertyInfo that represents the child collection for the specified 
		/// TypeFk
		/// </summary>
		/// <param name="typeFk"></param>
		/// <returns></returns>
		protected internal PropertyInfo GetChildCollectionDaoPropertyForTypeFk(TypeFk typeFk)
		{
			Type primaryDaoType = GetDaoType(typeFk.PrimaryKeyType);
			Type foreignKeyDaoType = GetDaoType(typeFk.ForeignKeyType);
			string propertyName = string.Format("{0}By{1}", foreignKeyDaoType.Name.Pluralize(), typeFk.ForeignKeyProperty.Name);
			PropertyInfo childCollectionPropertyForTypeFk = primaryDaoType.GetProperty(propertyName);
			return childCollectionPropertyForTypeFk;
		}

        protected Dao GetDaoInstanceById(Type baseOrWrapperType, long id)
        {
            return GetDaoInstanceByMethod("GetById", baseOrWrapperType, (object)id);
        }

        protected Dao GetDaoInstanceById(Type baseOrWrapperType, ulong id)
        {
            return GetDaoInstanceByMethod("GetById", baseOrWrapperType, (object)id);
        }

		protected void SaveDaoInstance(Type dtoOrPocoType, object daoInstance)
		{
			MethodInfo? saveMethod = GetDaoType(dtoOrPocoType).GetMethod("Save", new Type[] { typeof(Database) });
            if(saveMethod != null)
            {
                try
                {
                    saveMethod.Invoke(daoInstance, new object[] { Database });
                }
                catch (Exception ex)
                {
                    LogAndThrow(ex, Logger);
                }
            }
            else
            {
                Logger.Info("'Save' method was not found on type ({0})", dtoOrPocoType?.FullName);
            }
		}


        protected object SaveDaoInstanceProperties(object poco, Dao daoInstance)
		{
			Meta.SetUuid(poco);
            Meta.SetCuid(poco);
			daoInstance.CopyProperties(poco);
			daoInstance.Property("Database", Database);
			Type pocoType = GetBaseType(poco.GetType());
			SaveDaoInstance(pocoType, daoInstance);
            bool saveAgain = false;
            object wrapper = this.Wrap(pocoType, poco);
			if (SetDaoCollectionValues(wrapper, daoInstance))
			{
                saveAgain = true;
			}
            if(SetDaoXrefCollectionValues(wrapper, daoInstance))
            {
                saveAgain = true;
            }
            if (saveAgain)
            {
                daoInstance.ForceUpdate = true;
                SaveDaoInstance(pocoType, daoInstance);
            }
			
            return SetPocoInstanceProperties(wrapper, daoInstance);
		}
		
        protected object SetPocoInstanceProperties(object poco, Dao daoInstance)
        {
            Type pocoType = GetBaseType(poco.GetType());
            object wrapper = ConstructWrapper(pocoType);
            wrapper.CopyProperties(daoInstance);

            SetPocoChildCollectionValues(wrapper, daoInstance);
            SetPocoXrefCollectionValues(wrapper, daoInstance);
            
            return wrapper;
        }

        private IEnumerable<TChildType> LoadForeignKeyCollection<TChildType>(object poco, ITypeFk fkDescriptor) where TChildType : new()
        {
            List<TChildType> results = new List<TChildType>();
            string foreignKeyName = fkDescriptor.ForeignKeyProperty.Name;
            ulong parentId = GetIdValue(poco).Value;
            if (parentId <= 0)
            {
                Type pocoType = poco.GetType();
                Logger.AddEntry("IdValue not found for specified parent instance: Type={0}.{1}, {2}", pocoType.Namespace, pocoType.Name, poco.ToString());
                return results;
            }
            // TODO: review why the call to Dao.MapUlongToLong is necessary 
            // potentially extract this into a separate ForeignKeyCollectionLoader implementation
            QueryFilter filter = Bam.Net.Data.Query.Where(foreignKeyName) == Dao.MapUlongToLong(parentId);
            Type childDaoType = GetDaoType(typeof(TChildType));
            MethodInfo whereMethod = childDaoType.GetMethod("Where", new Type[] { typeof(QueryFilter), typeof(IDatabase) });
            IEnumerable daoResults = (IEnumerable)whereMethod.Invoke(null, new object[] { filter, Database });

            foreach (object dao in daoResults)
            {
                Type wrapperType = GetWrapperType<TChildType>();
                TChildType value = wrapperType.Construct<TChildType>(this);
                value.CopyProperties(dao);
                results.Add(value);
            }

            return results;
        }

        private Dao GetDaoInstanceByUniversalIdentifier(Type baseOrWrapperType, string uuid)
        {
            return GetDaoInstanceByMethod("GetByUuid", baseOrWrapperType, (object)uuid);
        }

        private Dao GetDaoInstanceByMethod(string methodName, Type baseOrWrapperType, object parameter)
        {
            Type pocoType = GetBaseType(baseOrWrapperType);
            Type daoType = GetDaoType(pocoType);
            MethodInfo getterMethod = daoType.GetMethod(methodName, new Type[] { parameter.GetType(), typeof(Database) });
            object daoResult = getterMethod.Invoke(null, new object[] { parameter, Database });
            if (daoResult == null)
            {
                return null;
            }
            return (Dao)daoResult;
        }

        private bool SetDaoXrefCollectionValues(object poco, IDao daoInstance, PropertyInfo daoXrefProperty, PropertyInfo pocoXrefProperty)
        {
            bool result = false;
            IEnumerable values = (IEnumerable)pocoXrefProperty.GetValue(poco);
            if (values != null)
            {
                IAddable daoXrefCollection = (IAddable)daoXrefProperty.GetValue(daoInstance);
                daoXrefCollection.Clear(daoInstance.Database);
                foreach (object o in values)
                {
                    Meta.SetUuid(o);
                    Meta.SetCuid(o);
                    Dao dao = GetDaoType(o.GetType()).Construct<Dao>();
                    dao.CopyProperties(o);
                    daoXrefCollection.Add(dao);
                    result = true;
                }
            }
            return result;
        }

        private void SetPocoXrefValues(object poco, IDao daoInstance, PropertyInfo daoXrefProperty, PropertyInfo pocoXrefProperty)
        {
            IEnumerable? daos = (IEnumerable?)daoXrefProperty.GetValue(daoInstance);
            if (daos != null)
            {
                if (!pocoXrefProperty.PropertyType.IsArray && pocoXrefProperty.PropertyType.IsEnumerable())
                {
                    SetPocoXrefListValues(poco, daos, pocoXrefProperty);
                }
                else
                {
                    SetPocoXrefArrayValues(poco, daos, pocoXrefProperty);
                }
            }
        }

        private void SetPocoXrefArrayValues(object poco, IEnumerable daos, PropertyInfo pocoXrefProperty)
        {
            Array? arr = pocoXrefProperty.GetValue(poco) as Array;
            Type? itemType = pocoXrefProperty.GetEnumerableType();
            if (arr != null && itemType != null)
            {
                int index = 0;
                foreach (object dao in daos)
                {
                    object item = itemType.Construct();
                    item.CopyProperties(dao);
                    arr.SetValue(item, index++);
                }
            }
        }

        private void SetPocoXrefListValues(object poco, IEnumerable daos, PropertyInfo pocoXrefProperty)
        {
            IList list = (IList)pocoXrefProperty.PropertyType.Construct();
            Type? itemType = pocoXrefProperty.GetEnumerableType();
            foreach (object dao in daos)
            {
                object item = itemType.Construct();
                item.CopyProperties(dao);
                list.Add(item);
            }
            pocoXrefProperty.SetValue(poco, list);
        }

        private void SetPocoArrayFromDaoCollection(TypeFk fkDescriptor, object poco, IEnumerable daoCollection)
        {
            Array arr = (Array)fkDescriptor.CollectionProperty.PropertyType.Construct();
            int index = 0;
            foreach (object dao in daoCollection)
            {
                object child = fkDescriptor.ForeignKeyType.Construct();
                child.CopyProperties(dao);
                arr.SetValue(child, index++);
            }
            fkDescriptor.CollectionProperty.SetValue(poco, arr);
        }

        private void SetPocoListFromDaoCollection(TypeFk fkDescriptor, object poco, IEnumerable daoCollection)
        {
            IList list = (IList)fkDescriptor.CollectionProperty.PropertyType.Construct();
            foreach (object dao in daoCollection)
            {
                object child = fkDescriptor.ForeignKeyType.Construct();
                child.CopyProperties(dao);
                list.Add(child);
            }
            fkDescriptor.CollectionProperty.SetValue(poco, list);
        }

        private static QueryFilter CreateQueryFilter(Dictionary<string, object> queryArguments)
        {
            Args.ThrowIf<ArgumentException>(queryArguments.Count == 0, "No query parameters specified");

            string first = queryArguments.Keys.First();
            QueryFilter filter = new QueryFilter(first) == Filter.Value(queryArguments[first]); // This uses operator overrides defined on QueryFilter to create the filter.  See QueryFilter.cs.
            if (queryArguments.Keys.Count > 1)
            {
                queryArguments.Keys.Rest(1, property =>
                {
	                object propertyValue = queryArguments[property];
	                if (propertyValue is ulong ulongPropertyValue)
	                {
		                propertyValue = Dao.MapUlongToLong(ulongPropertyValue);
	                }
                    filter.And(new QueryFilter(property) == Filter.Value(propertyValue));
                });
            }
            return filter;
        }

        private object CreateWrapperCopy(Type objectType, Dao daoInstance)
        {
            object pocoWrapper = ConstructWrapper(objectType);
            pocoWrapper.CopyProperties(daoInstance);
            SetParentProperties(pocoWrapper);
            return SetPocoInstanceProperties(pocoWrapper, daoInstance);
        }

        private void WarnRetrieveAll<T>() where T : class, new()
        {
            Type type = typeof(T);
            WarnRetrieveAll(type);
        }

        private void WarnRetrieveAll(Type type)
        {
            string msgSignature = "Use of this method ({0}) can have a potential detrimental performance hit because it will retrieve all records for type ({1})";
            string[] messageArgs = new string[] { "RetrieveAll", type.Name };
            Logger.AddEntry(msgSignature, LogEventType.Warning, messageArgs);
            if (WarningsAsErrors)
            {
                string message = string.Format(msgSignature, messageArgs);
                message = string.Format("{0}\r\n\r\nTo suppress this exception set WarningsAsErrors to false", message);
                Args.Throw<InvalidOperationException>(message);
            }
        }

        private static void LogAndThrow(Exception ex, ILogger logger)
        {
            logger = logger ?? Log.Default;
            string message = ex.Message;
            string innerMessage = "NA";
            string signature = "ExceptionMessage::{0}::InnerExceptionMessage::{1}";
            Exception e = ex;            
            if(ex.InnerException != null)
            {
                e = ex.InnerException;
                innerMessage = ex.InnerException.Message;
            }
            logger.AddEntry(signature, e, message, innerMessage);
        }
    }
}
